---
title: Insert title here
key: a3fa20960c6b8ae43c264fc72c6b6202

---
## Common tests

```yaml
type: "TitleSlide"
key: "ff902d613c"
```

`@lower_third`
name: Name Surname
title: Instructor


`@script`
To ensure that a function works as expected, it is not enough to test the function for just one input.


---
## Which inputs to test?

```yaml
type: "FullSlide"
key: "be4746fc7b"
```

`@part1`
```python
def divides(denominator, numerator):
    if numerator % denominator == 0:
        return True
    return False
```

| Input | Expected return value | Function returns |
|----------|--------|--------|
| (2, 6) | True | True |


`@script`
You need to test the function for a list of inputs. In general, the more inputs you check, the more confident you can be that the function doesn’t have bugs.


---
## Which inputs to test?

```yaml
type: "FullSlide"
key: "65765a007e"
disable_transition: true
```

`@part1`
```python
def divides(denominator, numerator):
    if numerator / denominator == 0:
        return True
    return False
```

| Input | Expected return value | Function returns |
|----------|--------|--------|
| (2, 6) | True | True |  
| (5, 25) | True | True |


`@script`



---
## Which inputs to test?

```yaml
type: "FullSlide"
key: "cf4aa8fe30"
disable_transition: true
```

`@part1`
```python
def divides(denominator, numerator):
    if numerator / denominator == 0:
        return True
    return False
```

| Input | Expected return value | Function returns |
|----------|--------|--------|
| (2, 6) | True | True |  
| (5, 25) | True | True |  
| (7, 41) | False | False |


`@script`



---
## Which inputs to test?

```yaml
type: "FullSlide"
key: "4821f7aa9f"
disable_transition: true
```

`@part1`
```python
def divides(denominator, numerator):
    if numerator / denominator == 0:
        return True
    return False
```

| Input | Expected return value | Function returns |
|----------|--------|--------|
| (2, 6) | True | True |  
| (5, 25) | True | True |  
| (7, 41) | False | False |
| ... | ... | ... |
| ... | ... | ... |
| (0, 9) | False | ZeroDivisionError |


`@script`
But how many inputs should you check? Since there are infinite possibilities for inputs, you cannot possibly check for everything.


---
## Which inputs to test?

```yaml
type: "FullSlide"
key: "862b424e5f"
disable_transition: true
```

`@part1`
```python
def divides(denominator, numerator):
    if numerator / denominator == 0:
        return True
    return False
```

| Input | Expected return value | Function returns |
|----------|--------|--------|
| (2, 6) | True | True |  
| (5, 25) | True | True |  
| (7, 41) | False | False |
| ... | ... | ... |
| ... | ... | ... |
| (0, 9) | False | ZeroDivisionError |


`@script`
And it is always possible you missed a critical input for which the function returns a buggy result.


---
## Which inputs to test?

```yaml
type: "FullSlide"
key: "f6df66a66c"
```

`@part1`
_Write 2 - 3 tests for each category of inputs_

- **Normal inputs**{{2}}
- **Special inputs**{{3}}
    - Boundary conditions{{3}}
    - Edge cases{{3}} 
- **Inputs that raise Exceptions**{{4}}


`@script`
The best practice is to write a 2 to 3 tests for each of the following categories of inputs, which are:

Normal inputs. 
Special inputs (boundary conditions and edge cases)
Inputs that should raise Exceptions

This ensures that the function is tested for a wide range of situations. An example will make things clearer.


---
## Example: Prime number detector

```yaml
type: "TwoRows"
key: "4b0729e5d8"
```

`@part1`
```python
def prime_number_detector(n):
    if not isinstance(n, int) or n < 1:
        raise ValueError(
            "Invalid input: {0}.".format(n)
            )
    elif all([n % i != 0 for i in range(2, n)]):
        return True
    return False
```


`@part2`
- `3` is a prime 
- `10 = 2 x 5`, not prime
- `1` is not a prime by convention


`@script`
I have defined a function that checks if a number is prime. 

A prime number is a positive integer that is not divisible by any smaller positive integers other than 1. 3 is a prime, because 3 is not divisible by any smaller positive integers other than 1. However, 10 is non prime, because it is divisible by 2, which is smaller than 10 and not 1. 

By convention, 1 is considered non prime. 

Let’s test this function for all the different kinds of inputs I talked about.


---
## Normal inputs

```yaml
type: "TwoRows"
key: "d2a9727eb8"
```

`@part1`
_Normal inputs_ are inputs that a function is frequently called with.

- Integers less than `100`{{2}}
    - `61` is a prime{{3}}
    - `77 = 7 x 11`, not prime{{4}}


`@part2`
```python
def test_is_prime(self):
    self.assertTrue(prime_number_detector(61))
```{{3}}

```python
def test_is_not_prime(self):
    self.assertFalse(prime_number_detector(77))
```{{4}}


`@script`
Normal inputs for this function are inputs that the function may be frequently called with. If, for your use case, you frequently call this function with positive integers less than 100, then you could test the function for a prime less than 100, say 61, and a non prime less than 100, let’s say 77.


---
## Special inputs

```yaml
type: "TwoRows"
key: "22d36aca50"
```

`@part1`
_Special inputs_ are inputs that lie at the edge or boundary of a functions domain.


`@part2`



`@script`
What are special inputs for this function? These are inputs that are at the edge or boundary of a function’s domain. Since we want this function to return a result for positive integers, 1 and 2 would be examples of edge cases.


---
## Let's practice!

```yaml
type: "FinalSlide"
key: "b21990ca23"
```

`@script`
Let’s practice this for some other functions!

